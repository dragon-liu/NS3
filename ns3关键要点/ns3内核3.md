## 一.对象模型

本节描述针对ns-3的对象设计。总体来说，ns-3中使用的设计模式包括经典的面向对象设计、接口与实现分离、非虚拟的公共接口设计模式、对象聚合以及引用计数内存管理模式。

#### 1.面向对象编程

​	因ns-3是基于C++开发，所以相应保留了C++所具有的面向对象编程的特点与语法规则，如封装性，继承性和多态性。

#### 2.对象基类

​	ns-3中提供了3个对象基类供用户继承。这3个基类分别是：**Object、ObjectBase、SimpleRefCount**。ns-3并不强迫每一个类都必须继承自这3个类，但是从这3个基类继承的类包含了ns-3提供的特有特性：

- 属性系统
- 对象聚合系统
- 智能指针和引用计数系统

从ObjectBase中继承的类包含上述前2个功能特性，但是不包含智能指针，从SimpleRefCount中继承的类只包含智能指针功能，只有从Object类继承的子类才具备以上3种特性。

#### 3.内存管理与引用计数指针(Ptr)

​	在C++程序中，内存管理一直是一个复杂问题，一旦操作不对就很有可能造成内存泄漏，而且如果用户使用了new操作符申请了内存，而忘记在变量无效时使用delete操作符释放内存，就容易导致内存不足的假象。因此，C++程序员在对new和delete的使用时要非常小心，这是程序员不愿意接受的。在ns-3中，使用引用计数设计模式来管理内存。

​	**所有使用引用计数的对象都持有一个内部的计数器来判断对象是否可以安全地删除，释放已分配的内存空间。当一个接口获得一个对象指针时，该对象的引用计数通过调用函数Ref()来增加1，同样当用户不再使用该指针时，用户有义务调用Unref()函数来减小引用计数，当引用计数器减少为0时，该对象就被删除。**

​	当用户通过构造函数或GetObject()函数（这个函数将在后面章节提到，这里知道就好）来获取指针时，引用计数不增加。
**当用户通过复制构造函数来获取一个指针时，引用计数增加。**
**所有的对象指针都必须通过Unref()来释放引用。**

这里用户最关心的莫过于Ref()和Unref()这2个函数怎么调用，需要谁调用。ns-3提供了引用计数智能指针来调用这些函数，用户在编程时基本不需要考虑这些，智能指针将在后面讲到。

a.引用计数指针(Ptr)

​	在编程时时时刻刻想着调用Ref）和Unref）是非常繁琐讨人厌的事，就好比使用new和delete一样，所以ns-3提供了引用计数指针Ptr类来处理上述函数调用。智能指针认为每一个基本类型提供一对函数Ref）和Unref）来增加和减小对象实例的引用计数。

​	智能指针的使用和C++里面指针的使用是相同的，可以被赋值为空，也可以通过其他指针来复制等，熟悉指针的用户用起来非常顺手。

​	**如果你想要让一个指针指向一个对象，建议你使用ns-3提供的CreateObject模版函数来创建类对象，并将其地址复制给指针以避免内存泄漏。ns-3提供的这个函数旨在为用户提供方便并减少代码量。**

b.CreateObject和Create

在C++中，对象的创建可以是动态的也可以使静态的，这些特征在ns-3中同样适用，不过ns-3还提供了一种创建方式，特别是针对包含引用计数的对象，就是通过模版函数CreateObject和Create来创建。
对于基类为Object的类创建对象的方法如下：

```c++
Ptr<MyObject>mo=CreateObject<Myobject>（）；
如：Ptr<WifiNetDevice>device=CreateObject<WifiNetDevice>（）；
```

**在ns-3中尽量地使用CreateObject()来创建类对象，而不是在C++中使用new操作符。只要这个类支持智能指针，强烈建议用户使用上述方法，这是对new操作符的一个封装，它能正确地处理智能指针引用计数。**



#### 4.聚合

​	ns-3中对象聚合系统是总结了ns-2中的缺点进而提出的。在ns-2中使用继承和多态来扩张协议模型。例如，TCP的特殊版本Reno TcpAgent 是由TcpAgent派生的，其对基类的函数进行了重写覆盖。也因如此，ns-2模型中出现了2个问题：向下类型转换（downcasts）和弱基类（weak base class）。向下类型转换是指一个过程，即使用指向某个基类对象的指针在程序运行时查询该指针获得类型的信息，然后该指针显示转换为子类的指针，以便子类的成员函数能被该指针使用。弱基类是指当某个类无法被有效地重用时，因为它可能缺少某种必要的功能，导致开发者不得不修改基类，这将导致基类API的增生，某些API可能并不是对所有的子类都是语义正确的。

​	**ns-3使用查询接口设计模式来避免这些问题。在ns-3中，类Node是使用聚合的一个很好的例子。注意ns-3中没有Node的子类，也就是说任何网络终端都使用相同的Node类，但是不同网络终端的构件和协议是不同的，那么怎么创建满足不同网络节点的需求呢？这就要使用聚合的方式将不同的构件协议聚合到节点中。**下面这个例子大家一起学习研究IPv4协议是如何被加入到节点中的。

```c++
static void
AddIpv4Stack(Ptr<Node>node)
{
    Ptr<IPv4L3Protocol> ipv4=Createobject<IPv4L3Protocol>(); 
    //创建一个IPv4协议的指针对象
    ipv4->SetNode (node); //把IPv4协议聚合到节点中，这样Node就不需要被编辑来使用户使用指向基类Node的指针来访问IPv4接口；用户可以在程序运行时向节点请求指向该节点IPv4接口的指针。值得注意的是：不能将同一类型的对象聚合到某一Object中，比如试图向一个节点中聚合2个路由协议是不正确的。
    node->AggregateObject (ipv4); 
    Ptr<IPv4Imp1>ipv4Impl=CreateObject<IPv4Impl>(); 
    ipv4Imp1->SetIPv4 (ipv4); 
    node->AggregateObject (ipv4Imp1);
}
```

考虑一个节点指针m_node，该指针指向一个节点对象，且先前已经将IPv4的实现聚合到了该节点。用户想要配置一个路由协议，为了实现这点，必须访问已经聚合到该节点的一个对象，且该对象具有IP配置接口。例如，

```c++
Ptr<IPv4>ipv4=m_node->Getobject<IPv4>()；
```

如果没有IPv4的对象被聚合到该节点上，那么该方法就会返回一个NULL。因此检查该函数调用的返回值是一个非常好的习惯。如果成功，则用户可以使用Ptr，该指针指向先前被聚合到该节点的IPv4对象。